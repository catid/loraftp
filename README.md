# This is a work in progress (doesn't work yet)

# LoRa FTP

File transfer between two Raspberry Pis using the LoRa Pi HAT from Waveshare.


## Ingredients

2x Waveshare Pi HATs
https://www.waveshare.com/wiki/SX1262_915M_LoRa_HAT

2x Raspberry Pi 4B:
https://www.raspberrypi.org/


## Quick Start

Set up the Pis and connect the hats.

Configure the DIP switches as shown here:

![alt text](https://github.com/catid/loraftp/raw/master/docs/waveshare_dips.jpg "DIP switch settings for LoRa HAT")

Clone the repo on both devices and build it:

```
    sudo apt install g++ cmake pigpio
    git clone https://github.com/catid/loraftp
    cd loraftp
    mkdir build
    cmake ..
    make -j
```

One of the devices hosts the file server:

```
    ./loraftp_server
```

The other device runs the file client.  To upload a file to the server:

```
    ./loraftp_client ../docs/waveshare_dips.jpg
```

This will place the file in the same folder as the server.


## Protocol

The client first compresses the file using Zstd to make sure that it is as small as possible.

The client and server both configure the radio for the highest performance bandwidth mode.

Before starting, both server and client check a subset of the 84 channels for noise power.
The HAT supports 84 channels: 850.125 + (channel * 1MHz).  Recall that LoRa uses 500 kHz spectrum bandwidth.


#### Client => Server OFFER (Packet # 0):

The client and server rendezvous on channel 42, by the server listening for an OFFER from the client.
The client transmits its noise power data to the server in this OFFER.

```
    0x00 0xfe 0xad 0x01
    <Channel RSSI (4 bytes)>
    <File Length (4 bytes)>
    <Filename Length(1 byte)> <Filename (X bytes)>
```


#### Server => Client ACCEPT (Packet # 1, 4 bytes):

The server replies with the channel selection, and then both radios are configured for the lowest noise channel.

```
    0x01 0xad 0xfe <Channel Selection 1..83 (1 byte)>
```


#### Client => Server DATA (235 bytes):

Data is generated by Wirehair FEC in a network coded stream.  As soon as "enough" data arrives, the file is received by the server.

```
    <Block ID (1 byte)> <Data (234 bytes)>
```

The Block ID is truncated to 1 byte.  It can be expanded back to 32-bits using the Counter library,
which assumes the counter is incrementing slowly.


#### Server => Client ACK (Packet # 3, 2 bytes):

The fastest we can send data is about 2 KB/s with this hardware, so most of the time is spent transmitting data.
Every 5 seconds, the roles reverse and the server sends an ACKnowledgement back.

```
    0x03 <Percentage Complete (1 byte)>
```

The server reports up to 99% until Wirehair FEC recovery completes, and then it reports 100% for 5 seconds,
at 100 millisecond intervals.


## Discussion and Future Work

This is using the simplified API exposed by the Waveshare HAT to the SX1262 LoRa chip, which cannot configure all the features of the chip.  Waveshare HAT has two bugs: (1) a bug where data can arrive truncated so we had to add len+crc framing format overhead, so it should be about 3% more efficient to use the SX1262 directly (2) a bug where the full 62.5 kbaud data rate is not achieved, in fact only a third of that can be achieved in practice.

LBT mode is not used because the LoRa HAT system is significantly slower (2 seconds between bursts) when it is turned on.

It does not support data security (key management) or time-division channel sharing or multi-hop relaying.


## Credits

Software by Christopher A. Taylor mrcatid@gmail.com

Please reach out if you need support or would like to collaborate on a project.
